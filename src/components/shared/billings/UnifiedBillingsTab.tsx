import { useState, useMemo, useRef, useEffect } from "react";
import { Search, X, Plus, Filter, Download, Loader2, Pencil, Check } from "lucide-react";
import { CustomDropdown } from "../../bd/CustomDropdown";
import { CustomDatePicker } from "../../common/CustomDatePicker";
import { BillingsTable } from "./BillingsTable";
import { CategoryPresetDropdown } from "../../pricing/quotations/CategoryPresetDropdown";
import { toast } from "../../ui/toast-utils";
import { projectId, publicAnonKey } from "../../../utils/supabase/info";
import type { QuotationNew } from "../../../types/pricing";

const API_URL = `https://${projectId}.supabase.co/functions/v1/make-server-c142e950`;

// Interface matching the backend response for billing items
export interface BillingItem {
  id: string;
  created_at: string;
  service_type: string;
  description: string;
  amount: number;
  currency: string;
  status: 'unbilled' | 'billed' | 'paid';
  quotation_category?: string;
  booking_id?: string;
  // Linking fields
  source_id?: string;
  source_quotation_item_id?: string; // Matching backend field for imported items
  source_type?: 'quotation_item' | 'billable_expense' | 'manual';
  is_virtual?: boolean;
  [key: string]: any;
}

interface UnifiedBillingsTabProps {
  items: BillingItem[];
  quotation?: QuotationNew; // New prop for reflective billing
  projectId: string; // Project Number
  bookingId?: string;
  onRefresh: () => void;
  isLoading?: boolean;
  readOnly?: boolean;
  /** Optional title override (defaults to "Project Billings") */
  title?: string;
  /** Optional subtitle override */
  subtitle?: string;
  /** Optional extra action buttons rendered alongside "Add Billing" */
  extraActions?: React.ReactNode;
}

const formatCurrency = (amount: number, currency: string = "PHP") => {
  return new Intl.NumberFormat("en-PH", {
    style: "currency",
    currency: currency,
    minimumFractionDigits: 2,
  }).format(amount);
};

export function UnifiedBillingsTab({ 
  items, 
  quotation,
  projectId, 
  bookingId, 
  onRefresh,
  isLoading = false,
  readOnly = false,
  title,
  subtitle,
  extraActions
}: UnifiedBillingsTabProps) {
  
  // -- Local State --
  const [localItems, setLocalItems] = useState<BillingItem[]>([]);
  const [activeCategories, setActiveCategories] = useState<Set<string>>(new Set());
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedStatus, setSelectedStatus] = useState("");
  const [dateFrom, setDateFrom] = useState("");
  const [dateTo, setDateTo] = useState("");
  const [selectedCategory, setSelectedCategory] = useState("");
  // Removed isImporting state as import button is gone
  // Removed isEditing state - now derived from readOnly
  const [pendingChanges, setPendingChanges] = useState(false);

  // Category Dropdown State
  const [showAddCategoryDropdown, setShowAddCategoryDropdown] = useState(false);
  const addCategoryBtnRef = useRef<HTMLButtonElement>(null);

  // Always edit mode if not read only
  const isEditing = !readOnly;

  // -- MERGE LOGIC --
  // Merges Real Billing Items with Virtual Quotation Items
  const mergedItems = useMemo(() => {
    // 1. Deep copy existing real items to avoid mutating props
    // We filter out items that will be replaced by the reflective logic to avoid duplicates if we push them later, 
    // OR we just update them in place. Updating in place is better to preserve IDs.
    const combined = items.map(item => ({ ...item }));
    
    // Create a map of "Source IDs" to their index in the combined array
    const realItemIndices = new Map<string, number>();
    
    combined.forEach((item, index) => {
        const sourceId = item.source_quotation_item_id || item.source_id;
        if (sourceId) {
            realItemIndices.set(sourceId, index);
        }
    });

    // If we have a quotation, reflect its items
    if (quotation && quotation.selling_price) {
        quotation.selling_price.forEach(cat => {
            cat.line_items.forEach(item => {
                const sourceId = item.id;
                const existingIndex = realItemIndices.get(sourceId);

                if (existingIndex !== undefined) {
                    // REAL ITEM EXISTS
                    // If the item is UNBILLED, we reflect the quotation changes live.
                    // This overwrites the DB value with the Quotation value in the UI.
                    // When saved, this new value becomes the persistent one.
                    const existingItem = combined[existingIndex];
                    
                    if (existingItem.status === 'unbilled') {
                        combined[existingIndex] = {
                            ...existingItem,
                            // Reflective fields (Overwrite DB with Quote)
                            description: item.description,
                            service_type: item.service || existingItem.service_type || "General",
                            amount: item.amount, // Calculated final price
                            currency: item.currency,
                            quotation_category: cat.category_name,
                            // Extended fields
                            quantity: item.quantity,
                            forex_rate: item.forex_rate,
                            is_taxed: item.is_taxed,
                            amount_added: item.amount_added,
                            percentage_added: item.percentage_added,
                            base_cost: item.base_cost
                        };
                    }
                    return; 
                }

                // NO REAL ITEM -> Create Virtual Item
                const virtualItem: BillingItem = {
                    id: `virtual-${item.id}`,
                    source_id: item.id, // We use generic source_id for internal tracking
                    source_quotation_item_id: item.id, // We set specific one for backend compatibility
                    source_type: 'quotation_item',
                    is_virtual: true,
                    created_at: quotation.created_at || new Date().toISOString(),
                    service_type: item.service || "General",
                    description: item.description,
                    amount: item.amount, // This is final_price (unit * qty * forex)
                    currency: item.currency,
                    status: 'unbilled', // Virtual items are always unbilled by definition
                    quotation_category: cat.category_name,
                    booking_id: bookingId || projectId,
                    // Extended fields for editing
                    quantity: item.quantity,
                    forex_rate: item.forex_rate,
                    is_taxed: item.is_taxed,
                    amount_added: item.amount_added,
                    percentage_added: item.percentage_added,
                    base_cost: item.base_cost
                };

                combined.push(virtualItem);
            });
        });
    }

    return combined;
  }, [items, quotation, projectId, bookingId]);

  // Sync merged items to local state when props change (and not pending changes)
  useEffect(() => {
     if (!pendingChanges) {
         setLocalItems(mergedItems);
         
         // Update categories based on merged items
         const cats = new Set(mergedItems.map(i => i.quotation_category || "General"));
         if (cats.size === 0) cats.add("General");
         setActiveCategories(cats);
     }
  }, [mergedItems, pendingChanges]);

  // -- Derived Data --
  // We use activeCategories state instead of deriving from items now, to support empty categories
  const categoriesList = useMemo(() => Array.from(activeCategories).sort(), [activeCategories]);

  const totalUnbilledAmount = useMemo(() => {
    return localItems
      .filter(i => i.status === "unbilled")
      .reduce((sum, i) => sum + (i.amount || 0), 0);
  }, [localItems]);

  const totalGrossAmount = useMemo(() => {
    return localItems
      .reduce((sum, i) => sum + (i.amount || 0), 0);
  }, [localItems]);

  // -- Filter Logic --
  const filteredItems = useMemo(() => {
    return localItems.filter((item) => {
      // 1. Search Query
      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        const matchesSearch = 
          (item.description || "").toLowerCase().includes(query) ||
          (item.service_type || "").toLowerCase().includes(query) ||
          (item.quotation_category || "").toLowerCase().includes(query);
        
        if (!matchesSearch) return false;
      }

      // 2. Status Filter
      if (selectedStatus && item.status !== selectedStatus) {
        return false;
      }

      // 3. Date Filter (created_at)
      if (dateFrom) {
        const itemDate = new Date(item.created_at);
        const fromDate = new Date(dateFrom);
        if (itemDate < fromDate) return false;
      }
      if (dateTo) {
        const itemDate = new Date(item.created_at);
        const toDate = new Date(dateTo);
        toDate.setHours(23, 59, 59, 999);
        if (itemDate > toDate) return false;
      }

      // 4. Category Filter
      if (selectedCategory) {
        const cat = item.quotation_category || "Uncategorized";
        if (cat !== selectedCategory) return false;
      }

      return true;
    });
  }, [localItems, searchQuery, selectedStatus, dateFrom, dateTo, selectedCategory]);

  const hasActiveFilters = dateFrom || dateTo || selectedCategory || selectedStatus || searchQuery;

  const handleClearFilters = () => {
    setDateFrom("");
    setDateTo("");
    setSelectedCategory("");
    setSelectedStatus("");
    setSearchQuery("");
  };

  // -- Handlers for Category Management --
  const handleAddCategory = (name: string) => {
    if (!name.trim()) return;
    setActiveCategories(prev => {
        const next = new Set(prev);
        next.add(name.trim());
        return next;
    });
    setPendingChanges(true);
  };

  const handleRenameCategory = (oldName: string, newName: string) => {
    if (!newName.trim() || oldName === newName) return;
    
    // 1. Update Category State
    setActiveCategories(prev => {
        const next = new Set(prev);
        next.delete(oldName);
        next.add(newName);
        return next;
    });

    // 2. Update Items
    setLocalItems(prev => prev.map(item => {
        const cat = item.quotation_category || "General";
        if (cat === oldName) {
            return { ...item, quotation_category: newName };
        }
        return item;
    }));
    setPendingChanges(true);
  };

  const handleDeleteCategory = (name: string) => {
      if (confirm(`Are you sure you want to delete category "${name}" and all its items?`)) {
          setActiveCategories(prev => {
              const next = new Set(prev);
              next.delete(name);
              return next;
          });
          setLocalItems(prev => prev.filter(item => (item.quotation_category || "General") !== name));
          setPendingChanges(true);
      }
  };

  const handleAddItemToCategory = (categoryName: string) => {
    const newItem: BillingItem = {
      id: `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      created_at: new Date().toISOString(),
      service_type: "",
      description: "",
      amount: 0,
      currency: "PHP",
      status: "unbilled",
      quotation_category: categoryName,
      booking_id: bookingId || projectId,
      // Default Extended Fields
      quantity: 1,
      forex_rate: 1,
      is_taxed: false,
      amount_added: 0,
      percentage_added: 0
    };
    
    setLocalItems(prev => [...prev, newItem]);
    setPendingChanges(true);
  };

  const handleItemChange = (id: string, field: string, value: any) => {
    // Phase 3: Handle deletion
    if (field === 'delete') {
        if (confirm("Remove this billing item?")) {
            setLocalItems(prev => prev.filter(i => i.id !== id));
            setPendingChanges(true);
        }
        return;
    }

    // Map view fields to backend fields
    let backendField = field;
    if (field === 'category') backendField = 'quotation_category';
    if (field === 'serviceType') backendField = 'service_type';
    
    // Ensure numeric types
    if (['amount', 'quantity', 'forex_rate', 'amount_added', 'percentage_added'].includes(field)) {
        value = Number(value) || 0;
    }

    setLocalItems(prev => prev.map(item => {
      if (item.id === id) {
        // If editing a virtual item, it's technically still virtual until saved,
        // but for the UI it behaves like a normal item being edited.
        // We might want to clear 'is_virtual' flag here? 
        // No, keep it until save so backend knows to create new.
        return { ...item, [backendField]: value };
      }
      return item;
    }));
    setPendingChanges(true);
  };

  const handleAddBilling = () => {
    const newItem: BillingItem = {
      id: `temp-${Date.now()}`,
      created_at: new Date().toISOString(),
      service_type: "",
      description: "",
      amount: 0,
      currency: "PHP",
      status: "unbilled",
      quotation_category: "Uncategorized",
      booking_id: bookingId || projectId // fallback
    };
    
    setLocalItems(prev => [newItem, ...prev]);
    setPendingChanges(true);
    toast.success("New billing row added. Edit details below.");
  };

  const handleSaveChanges = async () => {
      try {
          // Prepare payload: we need to send ALL items that have changed or are virtual
          // We send the whole 'localItems' list (or at least the virtual/modified ones)
          // For simplicity and to ensure order/completeness, we send all.
          // The backend batchUpsert handles ID generation for virtuals.
          
          toast.info("Saving changes...");
          
          const response = await fetch(`${API_URL}/accounting/billings/batch`, {
              method: 'POST',
              headers: {
                  "Content-Type": "application/json",
                  "Authorization": `Bearer ${publicAnonKey}`
              },
              body: JSON.stringify({ 
                  items: localItems,
                  project_id: projectId
              })
          });
          
          const result = await response.json();
          
          if (result.success) {
              toast.success("Changes saved successfully");
              setPendingChanges(false);
              onRefresh(); // Reload to get the real IDs from the backend
          } else {
              toast.error(result.error || "Failed to save changes");
          }
          
      } catch (error) {
          console.error("Error saving billings:", error);
          toast.error("Failed to save changes");
      }
  };

  const handleCancelChanges = () => {
      if (confirm("Discard all unsaved changes?")) {
        setLocalItems(mergedItems); // Revert to merged state
        setPendingChanges(false);
      }
  };

  return (
    <div className="flex flex-col bg-white">
      {/* Header Section */}
      <div className="flex items-start justify-between mb-8">
        <div>
          <h1 className="text-[32px] font-semibold text-[#12332B] mb-1 tracking-tight">
            {title || "Project Billings"}
          </h1>
          <p className="text-[14px] text-[#667085]">
            {subtitle || "Manage, track, and bill charges across all linked bookings."}
          </p>
        </div>
        
        <div className="flex items-center gap-3">
            {/* Save / Cancel Controls */}
            {pendingChanges && (
                <>
                    <button
                        onClick={handleCancelChanges}
                        className="flex items-center gap-2 px-4 py-2 bg-white border border-[#D0D5DD] text-[#344054] rounded-lg hover:bg-[#F9FAFB] transition-colors font-medium text-[14px]"
                    >
                        <X size={16} />
                        Cancel
                    </button>
                    <button
                        onClick={handleSaveChanges}
                        className="flex items-center gap-2 px-4 py-2 bg-[#0F766E] text-white rounded-lg hover:bg-[#0D6559] transition-colors font-medium text-[14px]"
                    >
                        <Check size={16} />
                        Save Changes
                    </button>
                </>
            )}

            {/* Add Billing Button */}
            {!readOnly && !pendingChanges && (
                <button
                    onClick={handleAddBilling}
                    className="flex items-center gap-2 px-4 py-2 bg-[#0F766E] text-white rounded-lg hover:bg-[#0D6559] transition-colors font-medium text-[14px]"
                >
                    <Plus size={16} />
                    Add Billing
                </button>
            )}
        </div>
      </div>

      {/* Contextual Actions (e.g., Rate Card Banner) */}
      {extraActions && (
        <div className="mb-4">
          {extraActions}
        </div>
      )}

      {/* Control Bar */}
      <div className="flex items-center gap-2 mb-4">
        {/* Search */}
        <div className="flex-1 relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-[var(--neuron-ink-muted)]" />
          <input
            type="text"
            placeholder="Search by Description, Service Type..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full pl-10 pr-4 py-2 rounded-lg focus:outline-none focus:ring-2 text-[13px] border-[1.5px] border-[var(--neuron-ui-border)] bg-white text-[var(--neuron-ink-primary)] focus:border-[#0F766E]"
          />
        </div>

        {/* Filters */}
        <div style={{ minWidth: "140px" }}>
           <CustomDatePicker value={dateFrom} onChange={setDateFrom} placeholder="Start Date" minWidth="100%" className="w-full px-4 py-2" />
        </div>
        <span className="text-[13px] text-[#6B7280] font-medium">to</span>
        <div style={{ minWidth: "140px" }}>
           <CustomDatePicker value={dateTo} onChange={setDateTo} placeholder="End Date" minWidth="100%" className="w-full px-4 py-2" />
        </div>
        
        {/* Status Filter */}
        <div style={{ minWidth: "140px" }}>
          <CustomDropdown
            value={selectedStatus}
            onChange={setSelectedStatus}
            options={[
              { value: "", label: "Status" },
              { value: "unbilled", label: "Unbilled" },
              { value: "billed", label: "Billed" },
              { value: "paid", label: "Paid" }
            ]}
            placeholder="Status"
          />
        </div>

        {/* Category Filter */}
        <div style={{ minWidth: "140px" }}>
          <CustomDropdown
            value={selectedCategory}
            onChange={setSelectedCategory}
            options={[{ value: "", label: "Category" }, ...categoriesList.map(c => ({ value: c, label: c }))]}
            placeholder="Category"
          />
        </div>

        {/* Add Category Button (Visible in Edit Mode) */}
        {isEditing && !readOnly && (
             <div className="relative">
                <button
                    ref={addCategoryBtnRef}
                    onClick={() => setShowAddCategoryDropdown(true)}
                    className="flex items-center gap-2 px-3 py-2 bg-white border border-[#D0D5DD] text-[#0F766E] rounded-lg hover:bg-[#F9FAFB] transition-colors font-medium text-[13px] h-10"
                >
                    <Plus size={16} />
                    Add Category
                </button>
                <CategoryPresetDropdown
                    isOpen={showAddCategoryDropdown}
                    onClose={() => setShowAddCategoryDropdown(false)}
                    buttonRef={addCategoryBtnRef}
                    onSelect={(cat) => {
                        handleAddCategory(cat);
                        setShowAddCategoryDropdown(false);
                    }}
                />
            </div>
        )}

        {hasActiveFilters && (
          <button
            onClick={handleClearFilters}
            className="flex items-center justify-center w-10 h-10 rounded-lg text-[#EF4444] hover:bg-[#FEF2F2] transition-colors shrink-0"
            title="Clear Filters"
          >
            <X size={18} />
          </button>
        )}
      </div>

      {/* Table Component */}
      <BillingsTable
        data={filteredItems.map(item => ({
          id: item.id,
          date: item.created_at,
          category: item.quotation_category || "Uncategorized",
          serviceType: item.service_type || "General",
          description: item.description,
          status: item.status,
          amount: item.amount,
          currency: item.currency || "PHP",
          originalData: item
        }))}
        isLoading={isLoading}
        emptyMessage="No billings found. Items from your quotation will appear here automatically."
        footerSummary={filteredItems.length > 0 ? {
          label: "Total Unbilled",
          amount: totalUnbilledAmount,
          currency: "PHP" 
        } : undefined}
        grossSummary={filteredItems.length > 0 ? {
          label: "Total Gross Billings",
          amount: totalGrossAmount,
          currency: "PHP"
        } : undefined}
        viewMode={!isEditing}
        onItemChange={handleItemChange}
        // Phase 3: Category Management Handlers
        activeCategories={activeCategories}
        onAddCategory={!readOnly ? handleAddCategory : undefined}
        onRenameCategory={!readOnly ? handleRenameCategory : undefined}
        onDeleteCategory={!readOnly ? handleDeleteCategory : undefined}
        onAddItem={!readOnly ? handleAddItemToCategory : undefined}
      />
    </div>
  );
}